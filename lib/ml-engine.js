import './onnxruntime-web.min.js';
const ort = globalThis.ort;

class MLEngine {
    constructor() {
        this.session = null;
        this.featureExtractor = null;
        this.backend = null;

        ort.env.wasm.wasmPaths = chrome.runtime.getURL('lib/');
        ort.env.wasm.numThreads = 1; 

        this.technicalKeywords = {
            'api': ['api', 'endpoint', 'rest', 'graphql', 'soap', 'route'],
            'database': ['db', 'database', 'sql', 'nosql', 'mongodb', 'postgres', 'mysql', 'store', 'query'],
            'auth': ['login', 'user', 'password', 'auth', 'credential', 'token', 'jwt', 'session', 'sign in', 'signup'],
            'payment': ['credit', 'card', 'payment', 'stripe', 'paypal', 'money', 'transaction', 'billing'],
            'file': ['upload', 'file', 'image', 'picture', 'document', 'pdf', 'csv', 'download'],
            'admin': ['admin', 'dashboard', 'settings', 'config', 'manage', 'delete', 'update', 'edit'],
            'data': ['data', 'analytics', 'report', 'stats', 'profile', 'email', 'phone', 'address']
        };
    }

    async initialize() {
        try {
            const modelUrl = chrome.runtime.getURL('models/requirement-model.onnx');
            const response = await fetch(modelUrl, { method: 'HEAD' });
            if (!response.ok) {
                throw new Error('ONNX model file not found.');
            }
            this.session = await ort.InferenceSession.create(modelUrl);
            this.backend = 'onnx';
            console.log('ML Engine initialized with ONNX model');
            return true;
        } catch (error) {
            console.warn('[VESSEL] Falling back to Mock Engine', error);
            this.backend = 'mock';
            return true;
        }
    }

    async classify(text, labels) {
        if (this.backend === 'mock' || !this.session) {
            console.warn('Model not loaded, using fallback');
            return this.fallbackClassify(text, labels);
        }

        try {
            const features = await this.extractFeatures(text);
            const inputTensor = new ort.Tensor('float32', Float32Array.from(features), [1, features.length]);
            const outputs = await this.session.run({ input: inputTensor });
            const scores = outputs.output.data;
            const results = [];
            for (let i = 0; i < labels.length; i++) {
                results.push({
                    label: labels[i],
                    score: scores[i]
                });
            }

            return results;
        } catch (e) {
            console.error("Inference failed", e);
            return this.fallbackClassify(text, labels);
        }
    }

    async extractFeatures(text) {
        const technicalFeatures = this.extractTechnicalIndicators(text);
        return technicalFeatures;
    }

    async detectInjection(text) {
        const lower = text.toLowerCase();
        const patterns = [
            'ignore previous',
            'system prompt',
            'forget everything',
            'new instructions',
            'you are now',
            'bypass',
            'do not follow'
        ];

        if (this.backend === 'mock') {
            for (let p of patterns) {
                if (lower.includes(p)) return 0.9;
            }
            return 0.1;
        }

        for (let p of patterns) {
            if (lower.includes(p)) return 0.9;
        }
        return 0.1;
    }

    async summarize(text) {
        return "Content summary generated by VESSEL (Placeholder).";
    }

    extractTechnicalIndicators(text) {
        const lower = text.toLowerCase();
        const features = [];

        // 1. Keyword cnt
        for (let [category, keywords] of Object.entries(this.technicalKeywords)) {
            let count = 0;
            for (let kw of keywords) {
                if (lower.includes(kw)) count++;
            }
            features.push(count);
            features.push(count > 0 ? 1 : 0);
        }

        // 2. Text stats
        features.push(text.length / 1000);
        features.push(text.split(/\s+/).length / 100);

        // 3. Specific indicators
        features.push(lower.includes('http') ? 1 : 0);
        features.push((/\d/).test(text) ? 1 : 0);

        return features;
    }

    fallbackClassify(text, labels) {
        console.log("Using fallback classification");
        return labels.map(label => ({
            label: label,
            score: text.toLowerCase().includes(label) ? 0.8 : 0.1
        }));
    }
}

export const mlEngineInstance = new MLEngine();
export { mlEngineInstance as MLEngine };
